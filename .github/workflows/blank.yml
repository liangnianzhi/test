name: Multi-Image Sync to Private Registry via Skopeo

on:
  # schedule:
    # - cron: '0 4,10,16,22 * * *'  # UTC 16:00 对应北京时间 00:00
  workflow_dispatch:

jobs:
  sync-images:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image_tag:
          # docker
          - { image: "emby/embyserver", tag: "4.8.11.0" } # 目前支持破解最新稳定版，有服务端破解方法
          - { image: "emby/embyserver", tag: "4.9.0.43" } # 目前支持破解最新测试版，有服务端破解方法，且网页端能正常访问，后续版本暂不能加载CssJs插件
          - { image: "emby/embyserver", tag: "beta" }
          - { image: "emby/embyserver", tag: "latest" }

        registry_target: ["docker.io/liangnianzhi"]  # 支持多目标扩展
      max-parallel: 2  # 每次仅运行两个任务
      fail-fast: false
    env:
      SOURCE_REGISTRY: "docker://docker.io"
      TARGET_REGISTRY: "docker://${{ matrix.registry_target }}"

    steps:
      # ---------------------
      # 阶段1：环境初始化
      # ---------------------
      - name: Setup Skopeo
        run: |
          # 添加官方容器工具仓库
          sudo apt install -y jq  # 安装核心工具，-y（-yes）自动确认

      # ---------------------
      # 阶段2：镜像元数据获取
      # ---------------------
      - name: Fetch image digest
        id: get-digest
        # env:
          # DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          API_URL="https://hub.docker.com/v2/repositories/${{ matrix.image_tag.image }}/tags/${{ matrix.image_tag.tag }}"
          
          # 可以使用${{ secrets.DOCKERHUB_TOKEN }}，也可使用${{ env.DOCKERHUB_TOKEN }}
          # digest=$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.digest')
          # images_digest=$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.images[].digest')
          # tag_last_pushed=$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.tag_last_pushed')
          # images_last_pushed=$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.images[].last_pushed')
          # tag_last_pushed_date=$(echo "$tag_last_pushed" | cut -d'T' -f1 | tr -d '-')
          # images_last_pushed_date=$(echo "$images_last_pushed" | cut -d'T' -f1 | tr -d '-')
          # 可以使用${{ secrets.DOCKERHUB_TOKEN }}，也可使用${{ env.DOCKERHUB_TOKEN }}
          
          echo "digest=$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.digest')" >> $GITHUB_OUTPUT # >>增量追加避免覆盖，>覆盖，后续步骤中通过 steps.<step-id>.outputs.<变量名> 访问，id必须设置，跨job传递需通过 outputs 字段显式映射
          # echo "images_digest=$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.images[].digest')" >> $GITHUB_OUTPUT
          # echo "tag_last_pushed=$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.tag_last_pushed')" >> $GITHUB_OUTPUT
          # echo "images_last_pushed=$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.images[].last_pushed')" >> $GITHUB_OUTPUT
          echo "tag_last_pushed_date=$(echo "$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.tag_last_pushed')" | cut -d'T' -f1 | tr -d '-')" >> $GITHUB_OUTPUT
          # echo "images_last_pushed_date=$(echo "$(curl -sLH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" $API_URL | jq -r '.images[].last_pushed')" | cut -d'T' -f1 | tr -d '-')" >> $GITHUB_OUTPUT

      # ---------------------
      # 阶段3：增量同步检查
      # ---------------------
      - name: Cache check
        uses: actions/cache@v3
        id: cache-check
        with:
          path: ./digests/digests.txt
          key: ${{ runner.os }}-${{ matrix.image_tag.image }}-${{ matrix.image_tag.tag }}-${{ steps.get-digest.outputs.digest }}
          # key: ${{ runner.os }}-${{ matrix.image_tag.image }}-${{ matrix.image_tag.tag }}-${{ steps.get-digest.outputs.digest || 'none' }}

      # ---------------------
      # 阶段4：镜像同步执行
      # ---------------------
      - name: Mirror image
        id: mirror-image
        if: steps.cache-check.outputs.cache-hit != 'true'
        env:
          SKOPEO_AUTHFILE: "/tmp/auth.json"  # 统一认证文件路径
        run: |
          # ========================
          # 动态识别源仓库逻辑
          # ========================
          # if [[ "${{ matrix.image_tag.image }}" == ghcr.io/* ]]; then
            # SOURCE_REGISTRY="docker://"          # ghcr镜像不需要额外前缀
          # else
            # SOURCE_REGISTRY="docker://docker.io/" # docker.io镜像需要前缀
          # fi
          
          # 安装skopeo
          wget https://github.com/lework/skopeo-binary/releases/download/v1.18.0/skopeo-linux-amd64 # 需跟随项目更新
          sudo mv skopeo-linux-amd64 /usr/bin/skopeo  
          sudo chmod +x /usr/bin/skopeo

          # 创建./digests文件夹，将steps.get-digest.outputs.digest存入./digests/digests.txt
          mkdir -p ./digests
          echo "${{ steps.get-digest.outputs.digest }}" > ./digests/digests.txt
          echo "${{ secrets.DOCKER_USER }}"
          echo "${{ secrets.DOCKER_PWD }}"
          # 动态生成镜像路径
          # image_name=$(echo "${{ matrix.image_tag.image }}" | awk -F/ '{print $NF}')
          # image_author=$(echo "${{ matrix.image_tag.image }}" | awk '{sub(/ghcr.io\//, ""); sub(/\/[^\/]*$/, ""); print}')
          # source_image="${{ env.SOURCE_REGISTRY }}/${{ matrix.image_tag.image }}:${{ matrix.image_tag.tag }}"
          # target_image="${{ env.TARGET_REGISTRY }}/$image_name.$image_author:${{ matrix.image_tag.tag }}-${{ steps.get-digest.outputs.tag_last_pushed_date }}"
          
          # 调试输出镜像名称和路径
          # echo "镜像名称: $image_name"  # 预期输出：embyserver
          # echo "镜像名称: $image_author"  # 预期输出：emby
          # echo "来源镜像: $source_image"  # 预期输出：docker://docker.io/emby/embyserver:beta
          # echo "目标镜像: $target_image"  # 预期输出：docker://docker.io/liangnainzhi/emby.embyserver:beta

          # 生成认证配置
          if [[ "${{ matrix.registry_target }}" == docker.io/* ]]; then
            skopeo login --authfile ${{ env.SKOPEO_AUTHFILE }} docker.io -u ${{ secrets.DOCKER_USER }} -p ${{ secrets.DOCKER_PWD }}
          elif [[ "${{ matrix.registry_target }}" == ghcr.io/* ]]; then
            skopeo login --authfile ${{ env.SKOPEO_AUTHFILE }} ghcr.io -u ${{ github.actor }} -p ${{ secrets.API_TOKEN }}
          fi

          # 执行镜像同步（支持自动重试）
          retry_count=0
          max_retries=3
          until [ $retry_count -ge $max_retries ]
          do
            skopeo copy --all --authfile ${{ env.SKOPEO_AUTHFILE }} --src-tls-verify=false --dest-tls-verify=false --retry-times 5 --override-os linux --override-arch amd64 "${{ env.SOURCE_REGISTRY }}/${{ matrix.image_tag.image }}:${{ matrix.image_tag.tag }}" "${{ env.TARGET_REGISTRY }}/$(echo "${{ matrix.image_tag.image }}" | awk -F/ '{print $NF}').$(echo "${{ matrix.image_tag.image }}" | awk '{sub(/ghcr.io\//, ""); sub(/\/[^\/]*$/, ""); print}'):${{ matrix.image_tag.tag }}-${{ steps.get-digest.outputs.tag_last_pushed_date }}" && break
              # \
              # \
              # --src-tls-verify=false \  # 适配自签名证书
              # --dest-tls-verify=false \ # 跳过HTTPS验证
              # \
              # --override-os linux \  # 跨平台兼容
              # \
              #  "$source_image" "$target_image" && break
            retry_count=$((retry_count+1))
            sleep $((RANDOM % 30))  # 随机退避
          done

          # 清理缓存
          sudo rm -rf /var/lib/containers/storage/cache/

      # ---------------------
      # 阶段5：元数据同步 (push to GHCR专用)
      # ---------------------
      - name: Sync metadata to GHCR
        if: contains(matrix.registry_target, 'ghcr.io')
        env:
          GITHUB_TOKEN: ${{ secrets.API_TOKEN }}
        run: |
          # 获取描述信息并转义
          desc=$(skopeo inspect ${{ env.SOURCE_REGISTRY }}/${{ matrix.image_tag.image }}:${{ matrix.image_tag.tag }} | jq -r '.Labels.description // "No description"' | jq -Rs .)

          # 调用GHCR API更新描述
          package_name=$(echo "${{ matrix.image_tag.image }}" | awk -F/ '{print $NF}')
          curl -X PATCH -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${{ secrets.USER_GITHUB }}/packages/container/$package_name/versions/$(skopeo inspect $source_image | jq -r .Digest)" -d "{\"metadata\":{\"description\":$desc}}"
      # ---------------------
      # 阶段6：元数据同步 (push to Docker专用)，还没针对ghcr.io源镜像优化
      # ---------------------
      - name: Sync Metadata to Docker
        # if: steps.cache-check.outputs.cache-hit != 'true' # 注释即使镜像不更新也更新description和full_description
        if: steps.mirror-image.outcome == 'success' # 仅在mirror-image步骤成功，skopeo copy 成功时执行元数据同步：
        env:
          # DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          image_name: $(echo "${{ matrix.image_tag.image }}" | awk -F/ '{print $NF}')
          image_author: $(echo "${{ matrix.image_tag.image }}" | awk '{sub(/ghcr.io\//, ""); sub(/\/[^\/]*$/, ""); print}')
          # DOCKER_USER: ${{ secrets.DOCKER_USER }}
          # DOCKER_PWD: ${{ secrets.DOCKER_PWD }}
          
        run: |
          # 获取源镜像元数据（包含description和full_description）
          RESPONSE=$(curl -sH "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}" "https://hub.docker.com/v2/repositories/${{ matrix.image_tag.image }}/")

          # 提取并处理Markdown内容（示例：转换相对链接）
          DESCRIPTION=$(echo "$RESPONSE" | jq -r '.description')
          # OVERVIEW=$(echo "$RESPONSE" | jq -r '.full_description' | sed 's|(\/|(https://github.com/${{ matrix.image_tag.image }}/raw/main/|g')  # 路径转换
          FULL_DESCRIPTION=$(echo "$RESPONSE" | jq -r '.full_description')  # 路径转换
          
          # 定义变量与转义 # 暂时不需要转义也可识别
          # 转义 DESCRIPTION（单行短文本）
          # DESCRIPTION_JSON=$(echo "$DESCRIPTION" | jq -Rs '@json')
          # 转义 FULL_DESCRIPTION（多行 Markdown）
          # FULL_DESCRIPTION_JSON=$(echo "$FULL_DESCRIPTION" | jq -Rs '@json')
          # FULL_DESCRIPTION_JSON=$(echo "$FULL_DESCRIPTION" | jq -Rs '@json' | jq .) #  处理 Markdown 中的嵌套 JSON
          
          # 构造 JSON Payload # 暂时不需要赋值转义参数
          # PAYLOAD=$(jq -n --arg desc "$DESCRIPTION_JSON" --arg full "$FULL_DESCRIPTION_JSON" '{description: $desc, full_description: $full}')
          PAYLOAD=$(jq -n --arg desc "$DESCRIPTION" --arg full "$FULL_DESCRIPTION" '{description: $desc, full_description: $full}')
          
          # 获取JWT ${TOKEN}登录dockerhub得到修改元数据的权限
          # TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d '{"username": "${{ env.DOCKER_USER }}", "password": "${{ env.DOCKER_PWD }}"}' https://hub.docker.com/v2/users/login/ | jq -r .token)
          TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d '{"username": "'"${{ secrets.DOCKER_USER }}"'", "password": "'"${{ secrets.DOCKER_PWD }}"'"}' https://hub.docker.com/v2/users/login/ | jq -r .token)

          # 调试输出
          # echo "${{ env.image_author }}"
          # echo "$FULL_DESCRIPTION"

          # 更新目标仓库元数据
          curl -X PATCH -H "Authorization: JWT ${TOKEN}" -H "Content-Type: application/json" "https://hub.docker.com/v2/repositories/liangnianzhi/$(echo "${{ matrix.image_tag.image }}" | awk -F/ '{print $NF}').$(echo "${{ matrix.image_tag.image }}" | awk '{sub(/ghcr.io\//, ""); sub(/\/[^\/]*$/, ""); print}')/" -d "$PAYLOAD"
          # curl -X PATCH -H "Authorization: JWT ${TOKEN}" -H "Content-Type: application/json" "https://hub.docker.com/v2/repositories/liangnianzhi/${{ env.image_name }}.${{ env.image_author }}/" -d "{\"description\": \"$DESCRIPTION_JSON\", \"full_description\": \"$FULL_DESCRIPTION_JSON\"}"
          # curl -XPATCH -H "Authorization: Bearer ${{ env.DOCKERHUB_TOKEN }}" -H "Content-Type: application/json" "https://hub.docker.com/v2/repositories/liangnianzhi/${{ env.IMAGE_NAME }}/" -d @- <<EOF { "description": "$DESCRIPTION", "full_description": "$OVERVIEW" } EOF
